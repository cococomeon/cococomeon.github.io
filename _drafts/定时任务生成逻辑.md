
## 以当前时间为基点的缺陷

![]({{site.url}}/assets/images/基点漂移.png)
线程停顿有可能会丢失定时任务，像上面的这个定时任务，设置的时间是每天的02:00:00触发，
代码中线程醒来后的计算定时任务的方式是以当前的时间(精确到秒级别)，生成下一个60秒的定时任务，然后执行完这60秒的定时任务以后生成下一个60秒的定时任务。

逻辑缺陷：以当前时间为基准点，生成下一个60秒的定时任务，线程休眠后醒来的时间可能已经过了生成定时任务的的那个时间，可能得原因有很多种，线程调度没有及时调度


单线程定时任务缺陷：由于时间基点的漂移，有可能计算定时任务的时候会丢是定时任务
|——————定时任务计算与执行———————|xxx没有及时调度的时间xxxx|———————定时任务计算与执行————————|——————--------定时任务计算与执行-----------|——————|
|开始，计算当前时间后60秒的定时任务并执行     |              时间基点漂移到这里|开始，计算当前时间后60秒的定时任务并执行            |开始，计算当前时间后60秒的定时任务并执行            |

如果把秒级别也回调，需要保证生成器不会回调，即在同一个1分钟内，不会生成两次定时任务，不然就会重复生成了。还有上面的休眠可以看出，有存在超过1分钟没有生成定时任务的情况， 而且还有边界问题，因为你生成的时间只要是在这个分钟内就行， 不管是哪个秒钟内的都可以，那么就可能出现在上一个59秒的时候生成，然后休眠个60秒到下一个59秒的时候在生成当前一分钟的定时任务，但是有可能休眠醒来的时间超过了这个59秒，到达了下一个一分钟了， 这个时候就会丢失上一个一分钟内的定时任务了， 所以这种线性的，以当前时间为定时任务基准的生成方式及其依赖操作系统调度的精准度。

可以参考xxl-job的定时任务生成逻辑：
xxl-job中根据匹配解析的定时任务规则，查询离当前时间5s内回触发的定时任务，然后放进时间轮中让另一条线程执行。
计算出当前定时任务的下一次执行时间，同时记录上一次的执行时间更新到数据库中。


想规避因为定时任务基点选择当前时间导致的时钟漂移这个问题，就需要再定时任务数据中存储运行态的执行信息，记录上一次定时任务执行的时间，与下一次定时任务的执行时间。


## misfire策略
Afa定时任务休眠时间小于零时会重新生成定时任务的原因猜想：
1. 以前的定时任务精确度为毫秒级别的，极有可能发生事超时没执行的现象。
2. 系统时钟往前拨动了，导致的这次休眠的时间的计算小于0
其实放眼现在主流的开源定时任务平台，当发生了定时任务漏触发的时候都是会有对应的misfire策略的，一般这个misfire策略对那些高频任务无关紧要，但是对那种一天执行一次的低频任务这个就有很重要的意义了
