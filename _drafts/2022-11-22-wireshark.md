
## **一. 分析基础**
tcp协议有序性保证的基础：seq与ack。

### **1.1 有序性保证**
tcp是全双工协议，两边可以同时发送和接收数据，两边保证数据包的有序性是通过两边各自记录自己的seq
进行，通过这个序列号的递增性，来保证两边数据的有序性


### **1.2 可靠性保证**

#### **1.2.1 检验和**
链路层有CRC, IP,TCP层有checksum， 主要目的是为了检测出网卡软硬件，电缆，中间的各种设备的干扰和信号失真导致的数据丢失。注意校验和只保证数据的
可靠性，不保证数据的安全性，假如有人非法篡改数据包，再把校验和也修改了是有可能的。这靠别的机制进行防御而非校验和。

#### **1.2.2 序列号与确认应答**
可靠性主要通过tcp中的ack标志位进行保证，当发送一个包(seq=a, len=b)以后需要收到对方的一个ack包(ack=a+b)，来保证包的可靠性。

#### **1.2.3 滑动窗口**
上面的序列号和确认应答机制发送一次数据就等待一个ack，这种方式明显太低效了，于是就有了滑动窗口的出现，在设置的滑动窗口期内，允许对方还没有响应ack，
便开始发送下一个数据，直至窗口用完，必须等待有ack回来才能重新开始传输。底层实现就是用到了大量的缓冲区进行实现，ack没回来之前，数据存放在缓冲区中。


#### **1.2.4 重传机制**
**【超时重传】**
发送一个包以后等待ack回来，等待一定时间后，还没回来就判定超时进行重传。这个超时时间不是一个设置的固定值，而是根据两边往返时间RTT
进行确认的，超时重传时间 ≈ 往返时间RTT + 抖动(RTT方差)


**【快速重传】**<br>
上面说的序列号和确认应答用来确保数据包的可靠性，当一个数据包发出去了，没有确认应答回来就要重传。那一来一回等确认应答，再根据超时时间来判定重传的效率明显又是很慢的。
如何加速这个超时重传的动作呢？<br>
为了加速这个过程，在滑动窗口机制的前提下，假如出现三个对同一个数据包的确认应答操作，则进行重传下一个数据包，这就是**快速重传**，不根据时间来判定数据的重传。
但是快速重传，会重传所有的包，给网络带来压力。因为假如中间发出了多个包，只回来了3个，客户端没办法判断是中间的哪三个包到了终点了，于是只能全部重传。

**【SACK】**<br>


#### **1.2.5 拥塞控制**




## **二. 分析技巧**

### **2.1 包过滤**



常用的过滤条件


### **2.2 过滤条件复用**
"Analyze" - ""

主动创建


根据包内容创建
选中包的某一个属性，右键 -> apply as filter



追踪连接的交互数据










- [Wireshark使用教程](https://www.jianshu.com/p/55ec409c739e)
- [TCP/IP简单理解](https://segmentfault.com/a/1190000020010279)
- [图解 TCP 重传、滑动窗口、流量控制、拥塞控制](https://zhuanlan.zhihu.com/p/135932018)
